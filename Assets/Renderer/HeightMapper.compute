#pragma kernel CSVertex
#pragma kernel CSFlatten

#define UNITY_INDIRECT_DRAW_ARGS IndirectDrawIndexedArgs
#include "UnityIndirect.cginc"

RWTexture3D<float> densities;
RWTexture3D<float3> colorsIn;
RWTexture2D<uint> maxHeight;

int size;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float3> colors;
RWStructuredBuffer<int> indices;

RWStructuredBuffer<uint> atomicCounters;

RWStructuredBuffer<UNITY_INDIRECT_DRAW_ARGS> cmdBuffer;

float3 normalMaxx(uint3 id) {
    float base = densities[id];
    float x = densities[id + uint3(1, 0, 0)];
    float y = densities[id + uint3(0, 1, 0)];
    float z = densities[id + uint3(0, 0, 1)];
    return normalize(float3(base-x, base-y, base-z));
}

[numthreads(8, 8, 8)]
void CSFlatten(uint3 id : SV_DispatchThreadID) {
}

[numthreads(8, 8, 1)]
void CSVertex(uint3 id : SV_DispatchThreadID) {
    int index = id.x + id.y * size;
    
    vertices[index] = float3(id.x, 0.0, id.y);

    uint oldValue = 0;
    InterlockedAdd(atomicCounters[1], 6, oldValue); 
    
    /*
    indices[oldValue + (flip ? 0 : 2)] = check[0];
    indices[oldValue + 1] = check[1];
    indices[oldValue + (flip ? 2 : 0)] = check[2];
    
    indices[oldValue + (flip ? 4 : 3)] = check[2];
    indices[oldValue + 5] = check[3];
    indices[oldValue + (flip ? 3 : 4)] = check[0];
    */
    

    InterlockedAdd(cmdBuffer[0].indexCountPerInstance, 6); 
}