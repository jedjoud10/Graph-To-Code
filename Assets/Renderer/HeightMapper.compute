#pragma kernel CSVertex
#pragma kernel CSFlatten

#define UNITY_INDIRECT_DRAW_ARGS IndirectDrawIndexedArgs
#include "UnityIndirect.cginc"

RWTexture3D<float> densities;
RWTexture3D<float3> colorsIn;
RWTexture2D<uint> maxHeight;

int size;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float3> colors;
RWStructuredBuffer<int> indices;
RWStructuredBuffer<UNITY_INDIRECT_DRAW_ARGS> cmdBuffer;

float3 normalMaxx(uint3 id) {
    float base = densities[id];
    float x = densities[id + uint3(1, 0, 0)];
    float y = densities[id + uint3(0, 1, 0)];
    float z = densities[id + uint3(0, 0, 1)];
    return normalize(float3(base-x, base-y, base-z));
}

// https://www.ronja-tutorials.com/post/047-invlerp_remap/
float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

[numthreads(8, 8, 8)]
void CSFlatten(uint3 id : SV_DispatchThreadID) {
    float base = densities[id];
    float secondary = densities[id + uint3(0, 1, 0)];
    float floatHeight = invLerp(base, secondary, 0.0) + id.y;
    uint height = (floatHeight / float(size)) * 0xFFFFFFFF;

    if (base < 0.0 && secondary > 0.0) {
        InterlockedMax(maxHeight[id.xz], height);
    }
}

[numthreads(32, 32, 1)]
void CSVertex(uint3 id : SV_DispatchThreadID) {
    int index = id.x + id.y * size;
    float height = (float(maxHeight[id.xy]) / float(0xFFFFFFFF)) * size;
    vertices[index] = float3(id.x, height, id.y);
    uint3 testing = uint3(id.x, height, id.y);
    colors[index] = colorsIn[testing];
    normals[index] = -normalMaxx(testing);

    if (any(id >= size-1)) {
        return;
    }

    int check[4] = { index, index + 1, index + size, index + size + 1 };

    uint oldValue = 0;
    InterlockedAdd(cmdBuffer[0].indexCountPerInstance, 6, oldValue);
    
    indices[oldValue] = check[2];
    indices[oldValue + 1] = check[1];
    indices[oldValue + 2] = check[0];
    
    indices[oldValue + 3] = check[3];
    indices[oldValue + 4] = check[1];
    indices[oldValue + 5] = check[2];
    


}