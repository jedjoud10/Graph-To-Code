
RWTexture2D<float> _5_write;
Texture2D _5_read;
SamplerState sampler_5_read;
float _6;
float _7;
float _8;
float4x4 _9;
float _13;
float _18;
float _19;
Texture1D _22_read;
SamplerState sampler_22_read;
float4x4 _28;
float _33;
float _34;
float _35;
float4x4 _38;
float _43;
float _44;
float _52;
float _57;
float _58;
float _61;
Texture1D _66_read;
SamplerState sampler_66_read;
float4x4 _72;
float _83;
float _84;
Texture1D _86_read;
SamplerState sampler_86_read;
float2 _96;
float2 _97;
Texture2D _98_read;
SamplerState sampler_98_read;
RWTexture3D<float> voxels_write;
RWTexture3D<float3> colors_write;
int size;
int3 permuationSeed;
int3 moduloSeed;
float3 scale;
float3 offset;
#include "Assets/Compute/Noises.cginc"
#include "Assets/Compute/SDF.cginc"
#include "Assets/Compute/Other.cginc"
// defined nodes: 21, depth: 1, index: 0, total lines: 19, argument count: 3 
void _4(float3 position,uint3 id, out float _4_output) {
	float3 _10 = mul(_9, float4(position, 1.0)).xyz;
	float3 _11 = _10;
	float2 _12 = _11.xz;
	float _14 = 0.0;
	float _15 = 1.0;
	float _16 = 1.0;
	[unroll]
	for(uint i = 0; i < 5; i++) {
		float2 _17 = _12 * _15 + hash21(float(i) * 6543.26912) * 2366.5437;
		float _20 = (cellular((_17) * _19).x - 0.5) * _18;
		_14 += _20 * _16;
		_15 *= _8;
		_16 *= _13;
	}
	float _21 = _14;
	float _23 = Remap(_21, _6, _7, 0.0, 1.0);
	float _24 = _22_read.SampleLevel(sampler_22_read, _23, 0).x;
	float _25 = Remap(_24, 0.0, 1.0, _6, _7);
	float _26 = _25;
	_4_output = _26;
}

// defined nodes: 77, depth: 0, index: 1, total lines: 68, argument count: 4 
void Voxel(float3 position,uint3 id, out float voxel, out float3 color) {
	const float3 _1 = float3(1,1,1);
	const float3 _2 = float3(0,0,0);
	const float _3 = 0;
	float _27 = SampleBounded(_5_read, sampler_5_read, (float2(id.xz) / size) * _1.xz + _2.xz, _3, (float(size) / 1)).x;
	float3 _29 = mul(_28, float4(position, 1.0)).xyz;
	float3 _30 = _29;
	float _31 = _30.y;
	float _32 = _27 + _31;
	const float2 _36 = float2(1.0,1.0);
	const float2 _37 = float2(1.0,1.0);
	float3 _39 = mul(_38, float4(_30, 1.0)).xyz;
	float3 _40 = _39;
	float2 _41 = _40.xz;
	float2 _42 = ((_41 + float3(123.8544f, 32.22354f, -359.4854f).xy) * _36.x);
	float _45 = (snoise((_42) * _44)) * _43;
	float _46 = (_41.x + _45 * _37.x);
	float2 _47 = ((_41 + float3(65.4238f, -551.1535f, 159.5435f).xy) * _36.y);
	float _48 = (snoise((_47) * _44)) * _43;
	float _49 = (_41.y + _48 * _37.y);
	float2 _50 = float2(_46,_49);
	float2 _51 = _50;
	float _53 = 0.0;
	float _54 = 1.0;
	float _55 = 1.0;
	[unroll]
	for(uint i = 0; i < 4; i++) {
		float2 _56 = _51 * _54 + hash21(float(i) * 6543.26912) * 2366.5437;
		float _59 = (snoise((_56) * _58)) * _57;
		_53 += _59 * _55;
		_54 *= _35;
		_55 *= _52;
	}
	float _60 = _53;
	float _62 = _60 - _61;
	const float _63 = 0;
	float _64 = min(_62,_63);
	float _65 = (-(_64));
	float _67 = Remap(_65, _33, _34, 0.0, 1.0);
	float _68 = _66_read.SampleLevel(sampler_66_read, _67, 0).x;
	float _69 = Remap(_68, 0.0, 1.0, _33, _34);
	float _70 = _69;
	float _71 = _32 - _70;
	float3 _73 = mul(_72, float4(_30, 1.0)).xyz;
	float3 _74 = _73;
	const float3 _75 = float3(10,10,10);
	float _76 = sdBox(_74, _75);
	const float _77 = 0.2;
	const float _78 = 0.4;
	float _79 = (snoise((_74) * _78)) * _77;
	float _80 = _76 + _79;
	float _81 = opUnion(_71, _80);
	float _82 = _81;
	float _85 = _30.y;
	float _87 = Remap(_85, _83, _84, 0.0, 1.0);
	float3 _88 = _86_read.SampleLevel(sampler_86_read, _87, 0).xyz;
	float3 _89 = _88;
	const float3 _90 = float3(0.2,0.2,0.2);
	float3 _91 = _70.xxx;
	float3 _92 = lerp(_89,_90,clamp(_91, 0.0, 1.0));
	const float3 _93 = float3(0,0,0);
	float2 _94 = _30.xz;
	const float _95 = 0;
	float4 _99 = _98_read.SampleLevel(sampler_98_read, _94 * _96 + _97, _95);
	float _100 = _99.x;
	const float _101 = 10;
	float _102 = _100 * _101;
	float3 _103 = _102.xxx;
	float3 _104 = lerp(_92,_93,clamp(_103, 0.0, 1.0));
	voxel = _82;
	color = _104;
}


#pragma kernel CS_4
[numthreads(32, 32, 1)]
// Name: CS_4, Scope name: _4, Scope index: 1, Outputs: 1, Arguments: 3
void CS_4(uint3 id : SV_DispatchThreadID) {
    uint3 remapped = uint3(id.x, 0.0, id.y);
    float3 position = (float3(remapped * 1) + offset) * scale;
    float _4_output;
    _4(position,id,_4_output);
    _5_write[id.xy] = _4_output;

}

#pragma kernel CSVoxel
[numthreads(8, 8, 8)]
// Name: CSVoxel, Scope name: Voxel, Scope index: 0, Outputs: 2, Arguments: 4
void CSVoxel(uint3 id : SV_DispatchThreadID) {
    uint3 remapped = uint3(id.xyz);
    float3 position = (float3(remapped * 1) + offset) * scale;
    float voxel;
    float3 color;
    Voxel(position,id,voxel,color);
    voxels_write[id.xyz] = voxel;
    colors_write[id.xyz] = color;

}