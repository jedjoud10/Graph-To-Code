
float _1;
float _2;
float4x4 _3;
float _9;
float _10;
float3 _15;
float3 _17;
float _20;
float _21;
float _24;
float _35;
RWTexture3D<float> voxels_write;
RWTexture3D<float3> colors_write;
RWTexture3D<float2> uvs_write;
int size;
int3 permuationSeed;
int3 moduloSeed;
float3 scale;
float3 offset;
#include "Assets/Compute/Noises.cginc"
#include "Assets/Compute/SDF.cginc"
#include "Assets/Compute/Other.cginc"

float3 ConvertIntoWorldPosition(float3 tahini) {
    return  (tahini + offset) * scale;
}

float3 ConvertFromWorldPosition(float3 worldPos) {
    return  (worldPos / scale) - offset;
}
// defined nodes: 14, depth: 1, index: 0, total lines: 34, argument count: 2 
void _19(float3 _18, out float _19_sdf_output) {
	
	float3 posCell = floor(_18);
	float3 posFrac = frac(_18);
	
	float output = 100.0;
	
	
	for(int z = -1; z <= 1; z++)
	for(int y = -1; y <= 1; y++)
	for(int x = -1; x <= 1; x++) {
	
	    float3 cell = float3(x, y, z) + posCell;
	    float3 tiled = fmod(cell, 32);
	    float3 randomOffset = hash33(tiled);
	
		float3 _22 = tiled;
		float _23 = hash13(_22);
		float _25 = _23 - _24;
	
	    if (_25 < 0.0) {
	        float3 checkingPos = cell + randomOffset;
	
			float3 _26 = checkingPos;
			float3 _27 = abs(_26 - _18);
			float _28 = _27.x;
			float _29 = max(_28, _27.y);
			float _30 = max(_29, _27.z);
			float _31 = _30;
	
	        output = min(output, _31);
	    }
	}
	
	float _32 = min(output, 1.0) * _21 + _20;
	_19_sdf_output = _32;
}

// defined nodes: 27, depth: 0, index: 1, total lines: 21, argument count: 3 
void Voxel(float3 position, out float voxel, out float3 color) {
	float3 _4 = mul(_3, float4(position, 1.0)).xyz;
	float3 _5 = _4;
	float _6 = (snoise((_5) * _2)) * _1;
	float _7 = _5.y;
	float _8 = _6 + _7;
	float2 _11 = _5.xz;
	float _12 = (snoise((_11) * _10)) * _9;
	float _13 = (abs(_12));
	float _14 = _8 + _13;
	float3 _16 = _5 * _15;
	float3 _18 = _16 + _17;
    float _19_sdf_output;
    _19(_18,_19_sdf_output);
	float _33 = _19_sdf_output;
	float _34 = _14 + _33;
	const float _36 = 2;
	float _37 = _35 / _36;
	float _38 = _13 / _37;
	float3 _39 = _38.xxx;
	const float3 _40 = float3(0.5,0.5,0.5);
	float3 _41 = _39 * _40;
	voxel = _34;
	color = _41;
}


#pragma kernel CSVoxel
[numthreads(8, 8, 8)]
// Name: CSVoxel, Scope name: Voxel, Scope index: 0, Outputs: 2, Arguments: 3
void CSVoxel(uint3 id : SV_DispatchThreadID) {
    uint3 remapped = uint3(id.xyz);
    //float3 position = (float3(remapped * 1) + offset) * scale
    float3 position = ConvertIntoWorldPosition(float3(remapped) * 1);
    float voxel;
    float3 color;
    Voxel(position,voxel,color);
    voxels_write[id.xyz] = voxel;
    colors_write[id.xyz] = color;

}